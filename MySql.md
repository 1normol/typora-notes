# MySql



## 索引

- 基于B+Tree的一种数据结构，为了提升查找效率
- 查找效率和二分查找一样，o(logn)

### 索引设计原则

- 索引的随机性越高，定位效率越高。
- 索引应尽可能选择唯一字段。
- 一张表中索引的数量不应该过多，每个索引都需要占用磁盘空间，另外修改表时，索引重构更新耗费时间。

- 在设置索引的时候尽可能避免随机性较低的字段，如性别。

### 索引类型

- Innodb存储引擎下，索引的数据结构都为B+树

#### 聚簇索引

- 也叫主键索引，每张表只会有一个聚簇索引，根节点存储索引值，叶子节点存储已排序的数据
- 聚簇索引不需要回表

#### 非聚簇索引

- 非聚簇索引每张表可以有多个，根节点存储索引值，叶子节点存储主键的值。
- 非聚簇索引需要先根据索引找到主键值，再回表使用主键索引查找数据

##### 辅助索引：

- 根节点存储索引值，叶子节点存储主键的值

##### 联合索引

- 多个字段联合定义的索引，和辅助索引一样，根节点存储索引值，叶子节点存储主键的值。
- 使用联合索引的时候需要注意避免违反最左前缀原则。

#### 覆盖索引

- 覆盖索引不是一种索引，而是一种现象，发生在非聚簇索引中，当要查询的列恰好是当前索引值，此时将不会进行回表操作。
- 查询时尽可能缩小查询范围，查询需要字段而不是Select *

## 调优

### 数据库设计

- 尽可能明确限制字段大小，根据

### 索引设计



### 慢查询日志，Explain执行计划



### 分库分表

#### 横向拆分

#### 总想拆分



### 主从架构，集群





## MVCC

### 概念：

- 多版本并发控制（一致性非锁定读）是为了解决MySql并发环境下读操作的一致性。为了使并发环境下读操作不被锁定。
- 底层依赖于undolog实现

### 不同隔离级别下的表现

- 示例

- 准备一张user表，字段id,name,pwd 开启事务并测试

- 假定三个线程，A线程开启事务写完后提交，B线程在A线程写完后开启事务，写完后提交，C线程开启事务后一直sleep直到A、B线程执行完进行读。

  #### A线程

  ```mysql
  BEGIN;
  	UPDATE `user` 
  	SET NAME = 'tt1' 
  	WHERE
  	ID = '1';
  COMMIT;
  ```

  #### B线程

  ```mysql
  BEGIN;
  	UPDATE `user` 
  	SET NAME = 'tt' 
  	WHERE
  	ID = '1';
  COMMIT;
  ```

  #### C线程

  ```mysql
  BEGIN;
  	SELECT NAME 
  	FROM
  	USER 
  	WHERE
  	ID = '1';
  COMMIT;
  ```

- 三个版本

- 1.A线程开启事务前的快照版本。

- 2.A线程结束之后，B线程开启事务时的版本。

- 3.B线程结束提交任务之后的版本。

#### read uncommited(读未提交)

- 读未提交的情况下，B线程可以读到A线程未提交的数据，这种情况下MVCC毫无意义

#### read commited(读已提交)

- 在读已提交的隔离级别下，C线程读到的将会是第三个版本，在这一隔离级别下读到的永远都是最新的数据。
- 违反了事务的隔离性。C事务和A事务同时开启事务，而A事务结束、B事务结束、C事务在当前事务下永远能读到最新的数据。

#### repeatable  read（可重复读）

- 在可重复读的隔离级别下，C线程的事务只要未提交，永远读到的时第一个版本。即开启事务时的快照版本。
- mysql默认隔离级别为可重复读，使用next key lock解决幻读问题。

#### serial（串行化）

- 串行化情况下，所有任务都是串行执行，MVCC也无意义。





## 日志

### redo log





### undo log 





### bin log

### 

## 分布式事务



### 2PC



### 3PC