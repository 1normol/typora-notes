# JVM

## 内存区域（运行时数据区）

### 程序计数器

#### 概念

- 程序计数器是JVM内存中一块很小的区域，用来记录当前线程所执行字节码的行号指示器。
- Java文件通过javac命令编译为字节码文件（.class），由解释器来将其转换为机械码从而让机器运行，解释器无法知道字节码执行的顺序，只负责运行。程序计数器就是负责记录当前字节码运行的顺序，每当一行字节码走完，他就会告诉解释器下一步该走哪里。

![image-20221213161351572](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221213161351572.png)

#### 作用

- 负责告知解释器字节码执行的顺序。
- 在并发环境中，可以负责记录当前线程执行的字节码行号由此来完成上下文切换。
- 程序计数器是线程私有的，且是运行时数据区唯一一块不会出现OOM的区域。

### 虚拟机栈

#### 概念

- 虚拟机栈由一个一个栈帧组成，它是JVM运行时数据区的一个核心，除了一些Native方法，其他的Java方法调用都是通过栈来实现。
- 虚拟机栈是线程私有的，方法的调用意味着一个栈帧的被压入虚拟机栈，而方法的结束意味着当前方法的栈帧出栈。

##### 栈帧：

- 栈帧由局部变量表，操作数栈，动态链接，方法返回地址组成。
  - 局部变量表：存放八种基本数据类型和对象引用地址
  - 操作数栈：用于方法执行存放中间计算结果以及临时变量。
  - 动态链接：主要服务于一个方法调用另一个方法的时候，当java编译为字节码文件之后，所有的变量和符号引用都保存在class文件的常量池中，当一个方法要调用另一个方法时，需要把符号引用转换为内存地址的直接引用，动态链接就是负责这一步。

#### 补充：

- 栈的空间并不是无限的，一般正常调用不会出现问题。但是当请求栈的深度大于jvm虚拟机栈的最大深度时，就会抛出StackOverFlowError错误。
- 当虚拟机栈运行动态扩展时，在无法申请到足够大的内存空间时会发生OOM。

### 本地方法栈

- 本地方法栈和虚拟机栈的作用几乎一样，不同的是，本地方法栈主要是用在Native方法。和虚拟机栈一样，它也是由一个个栈帧组成，栈帧中有局部变量表，操作数栈、动态链接等。
- 本地方法栈是线程私有的。

### 堆

#### 基本概念

- 堆是Java内存区域中最大的一块，它是线程共享的一块内存区域，在JVM启动时创建。堆的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在堆中分配内存。
- 堆同时也是GC回收的主要区域，从垃圾回收的角度来看，现在的垃圾回收算法基本都采用分代回收算法，因此堆可以分为新生代，老年代，其中，新生代又可以细分为Eden区、S0区、S1区。

#### 逃逸分析

- 方法逃逸：在一个方法内，定义了一个局部变量，而这个局部变量被其他方法引用，或者作为值传递给其他方法，那么可以理解为对象跳出了方法。
- 线程逃逸：对象被其他线程访问，或者赋值实例变量，并被其他线程访问，可以理解为该对象掏出了当前线程。

##### 对象创建过程

- 对于一个对象，首先应该判断它是否满足栈上分配的条件，如果满足，则进行栈上分配，这也就是逃逸分析的用处。
- 如果不满足栈上分配，应该在堆中进行分配。
- 对于堆来说，大对象应该直接进入老年代，而非新生代。

### 方法区

#### 概念

- 方法区是JVM内存区域中的一块逻辑区域，是线程共享的，可以看作一个抽象概念和规范，他具体的实现是由元空间实现，JDK8之前由永久代实现。
- 当JVM要使用一个类时，它需要读取并解析Class文件获取相关的信息，并存入方法区，方法区会存储已被JVM加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。



## 垃圾回收

### 内存分配和回收原则

#### 垃圾标记阶段

- 判断对象存活的算法

  - 引用计数法，当一个对象被其他对象引用时，那么在其引用计数器上加一，在结束引用时，则在引用计数器上减一，当一个对象引用计数为0时，代表没有对象引用，可以进行回收。
    - 优缺点：实现简单，效率高。但是无法解决循环引用问题。
  - 可达性分析算法：以一些列"GC Root"作为根起点，通过引用关系向下搜寻，搜索的路径称为引用链，如果目标对象没有任何引用链，则表示不可达，可以被回收。
    - GC Roots对象：除了堆中，其他运行时数据区的都有可能作为GC Roots的对象。
      - 虚拟机栈引用的对象
      - 本地方法栈引用的对象
      - 方法区中类静态属性引用的对象
      - 方法区中常量引用的对象
      - 所有被同步锁持有的对象
      - 虚拟机的内部引用

- 常见的引用类型

  - 强引用：正常new出来的对象都是强引用，无论何时，只要有强引用关系的对象，都不会被垃圾回收器所回收。

  - 软引用：有软引用关系的对象，当内存即将不足时，会被垃圾回收器回收。

  - ```java
    package ref;
    import java.lang.ref.SoftReference;
    public class SoftRefTest {
        public static void main(String[] args) {
            SoftReference<String> softReference = new SoftReference<>(new String("Hello World"));
            System.out.println(softReference.get());
            System.gc();
            // 根据 老年代 大小进行设置，占满内存
            byte[] bigSize = new byte[1024 * 7168 - 354 * 1024];
            System.out.println(softReference.get());
        }
    }
    //设置vm option :-Xms10m -Xmx10m -XX:+PrintGCDetails
    //可以看到，当我们去占满内存的时候，软引用对象直接被清理掉了。最后获取其引用对象为 null。
    ```

  - 弱引用：有弱引用关系的对象，在下一次GC发生时，它就会被回收。

  - ```java
    package ref;
    import java.lang.ref.WeakReference;
    public class WeakRefTest {
        public static void main(String[] args) {
            WeakReference<String> weakReference = new WeakReference<>(new String("Hello World"));
            System.out.println(weakReference.get());
            System.gc();
            System.out.println(weakReference.get());
        }
    }
    //当GC回收发生之后，弱引用得到的对象为null
    ```

    

  - 虚引用：最弱的引用，无法通过虚引用获得对象信息，只能通过其引用队列得到相关信息。

### 垃圾清除阶段

- 当区分出内存中存活对象和死亡对象时，GC接下来应该进行垃圾回收，释放掉无用对象所占用的空间。

##### 常见垃圾收集算法

- 标记-清除算法（mark-sweep）
  - 从GC root引用链上判断对象是否不可达，如果是，则进行标记。
  - 将可以作为垃圾的对象从内存中直接清除。
  - 速度快，但是会产生内存碎片。
- 标记-复制算法
  - 从GC root引用链上判断对象是否不可达，如果是，则进行标记。
  - 复制算法将开辟两片相同大小的内存区域，当对象被标记为可回收对象时，先将对象移动到另一片区域(to)中，再对原区域（from）回收。
  - 会浪费一半的内存空间，不会产生内存碎片。
- 标记-整理算法
  - 从GC root引用链上判断对象是否不可达，如果是，则进行标记。
  - 在垃圾清理的过程中，将可用对象的内存向前移动，避免产生内存碎片。
  - 不会产生内存碎片，但是因为有对象移动的成本，效率较低。

##### 分代回收

- 对象首先分配在eden区，当eden区空间满之后，会进行一次minGC。
- minGC会将存活的对象复制算法将from区的对象和eden区的对象放入to区，并将from区和to区交换，在经历过一次minGC后仍然存活的对象将在对象头中的mark word的年龄标记+1；
- 当新生代对象的年龄达到阈值（看具体垃圾回收器的策略，有的是6，有的是15），对象将进入老年代。当然，新生的大对象由于年轻代空间不足也会进入老年代。
- 当老年代的空间将满时，会触发一次fullGC，fullGC会对年轻代和老年代的垃圾进行一次回收。

### 垃圾收集器

#### 常见组合

- serial +serial old ，串行化垃圾处理器，jvm最早的垃圾处理器。
- parnew+cms：parnew为年轻代的垃圾回收器，能够并行处理垃圾。cms为老年代的垃圾回收器，他是第一个真正意义上做到用户线程和垃圾回收线程并发执行的垃圾回收器。
- paraller scanvenge+paraller old：JDK8默认的垃圾回收器，年轻代使用praller scanvenge 老年代使用paraller old。这个垃圾回收器也叫吞吐量优先垃圾回收器，更加关注吞吐量，有自适应策略。
- g1：JDK9-17的默认垃圾回收器。
- 从g1开始，分代回收的概念逐渐弱化，尽管g1仍然保留了分代回收的逻辑，但他实际上是将堆内存分为一块一块的region区域。ZGC完全摒弃了分代的概念。



##### CMS垃圾收集器

- ##### 垃圾回收流程

  - 初始标记，这一阶段，仅仅标记可以作为GC root的对象，有非常短暂的stop the world
  - 并发标记，遍历gc root引用链上的对象，这一步不会stop the world
  - 重新标记，补充并发标记阶段新增的能作为gc root引用链上的对象，这一步会有stop the world，但时间相对较短，因为只是对并发标记的补充。
  - 并发清除，采用标记-清除算法，清除可以作为垃圾的对象。不会stop the world

- 优点

  - 低延时
  - 并发收集

- 缺点

  - 清除算法将会导致内存中有大量空间碎片，无法使用指针碰撞分配内存，只能使用空闲列表。由于并发清除这一阶段本身不会stop the world，用户线程和垃圾线程并发执行，无法使用标记整理算法。

  - 牺牲了一定的吞吐量，并发标记和并发清除阶段，垃圾线程和用户线程并发执行，但是cpu留给jvm的线程是有限的。

  - 无法清除浮动垃圾，并发清除阶段，用户线程和垃圾回收线程并发执行，这一阶段产生新的垃圾无法被回收，只能在下一次gc的时候才能被回收。

    



## 类加载

### 类加载过程

- 加载：通过类加载器，根据类的全限命名将class文件转换为二进制字节流文件。
- 连接
  - 验证：文件格式验证，元数据验证、字节码验证、方法引用验证等
  - 准备：为静态变量分配内存，赋初始值
  - 解析：将符号引用转换为直接引语。
- 初始化：
  - 只有当对类主动使用的时候才会导致类的初始化。
  - 使用new关键字实例化对象
  - 读取或设置一个静态属性，调用一个类的静态方法。
  - 使用反射的方法对类进行反射调用。
  - 初始化类时如果其父类未被初始化，则将先初始化其父类。
  - JVM启动的时候，用户需要制定一个运行的主类，JVM会先初始化这个类。
- 使用：
- 卸载：满足类卸载的要求如下
  - 该类的所有实例变量都已被回收。
  - 该类的类加载器已被回收。
  - 该类没有在其他任何地方被引用。

### 类加载器

#### 类加载器总结：

- BoostrapClassLoader：启动类加载器，最顶层的类加载器，负责加载lib目录下的Jar包。
- ExtClassLoader：扩展类加载器，负责加载ext目录下的jar包。
- AppClassLoader：应用类加载器，面向用户的加载器，负责加载classPath下的类和jar包。

#### 双亲委派机制：

- 类加载的时候首先会把类委派给他的父类加载器处理（loadClass方法），如果父加载器处理不了该请求，则向下传递。也就是说，每一个请求都会被传送到最顶层（BootstrapClassLoader）。
- Ext加载器并不能直接获取到其父类加载器，在委派过程中，当父类加载器为null时，会使使用BootstrapClassLoader处理请求，再向下传递。

##### 优势：

- 避免类的重复加载，JVM区分类不仅是根据类的全限命名，不同类加载器加载出来的类不是同一个类。
- 保护核心API不被篡改，比如自己实现一个Object类。

##### 如何打破双亲委派

- 自定义类加载器的时候，需要继承ClassLoader。重写其中的loadClass（）方法