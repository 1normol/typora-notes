# MySql



## 索引

- 基于B+Tree的一种数据结构，为了提升查找效率
- 查找效率和二分查找一样，o(logn)

### 索引设计原则

- 索引的随机性越高，定位效率越高。
- 索引应尽可能选择唯一字段。
- 一张表中索引的数量不应该过多，每个索引都需要占用磁盘空间，另外修改表时，索引重构更新耗费时间。

- 在设置索引的时候尽可能避免随机性较低的字段，如性别。

### 索引类型

- Innodb存储引擎下，索引的数据结构都为B+树

#### 聚簇索引

- 也叫主键索引，每张表只会有一个聚簇索引，根节点存储索引值，叶子节点存储已排序的数据
- 聚簇索引不需要回表

#### 非聚簇索引

- 非聚簇索引每张表可以有多个，根节点存储索引值，叶子节点存储主键的值。
- 非聚簇索引需要先根据索引找到主键值，再回表使用主键索引查找数据

##### 辅助索引：

- 根节点存储索引值，叶子节点存储主键的值

##### 联合索引

- 多个字段联合定义的索引，和辅助索引一样，根节点存储索引值，叶子节点存储主键的值。
- 使用联合索引的时候需要注意避免违反最左前缀原则。

#### 覆盖索引

- 覆盖索引不是一种索引，而是一种现象，发生在非聚簇索引中，当要查询的列恰好是当前索引值，此时将不会进行回表操作。
- 查询时尽可能缩小查询范围，查询需要具体字段而不是Select *以减少回表。

### 索引下推（ICP）

#### 概念

- 索引下推是指本该在服务层完成的操作下推到了存储引擎层，是Mysql5.6开始其为联合索引实现的一个优化，主要是为了减少回表。
- Explain中的extra字段如果显示Using Index Condition，代表使用到了索引下推。
- 索引下推只存在于联合索引

#### 实例

- 默认下实例使用InnoDb存储引擎

```sql
##假设在一张表中存在age,name,address字段，且联合索引为(age,name)
select * from table where age = 18 and name = %张 and address = "北京"
##在5.6之前，没有使用索引下推的版本。Mysql只会走age索引，联合索引name因为模糊查询失效，此时只能根据age筛选出字段，再进行回表。
##在使用了索引下推之后，mysql会在存储引擎层，尽管联合索引失效，它仍会在存储引擎层进行%name%的筛选，根据筛选条件，过滤完的数据在进行回表。
```



## 调优

### 表设计

- 尽可能明确字段大小，假如主键为bigint,占8个字节，指针默认6个字节，那么一个三层的b+树，在存储1kb的数据时，可以存储上千万条，存储16kb的数据时，可以存储百万条。
- 遵循B+树的高扇出性

### 索引设计

- 建立索引时要选择查询频率较高的列作为索引，且该列的随机性不应过低，最佳的情景应在where字句的条件中提取，如果where字句条件多，应该挑用最常用的且过滤条件最好的列。
- 对于blob,text或很长的varchar列必须使用前缀索引，索引占用空间大将会严重影响b+树的高扇出性。需要注意的是，MySql无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖索引。
- 一般情况下，一张表索引的个数尽量不超过5个。索引需要额外的磁盘空间，会在一定程度上降低写操作的性能，在修改表结构时，索引会进行更新与重构，索引列越多，耗费时间就越长。
- 更新频率高的字段不适合创建索引。

### 慢查询日志，Explain执行计划

#### 开启慢查询日志

- 临时生效，show variables like %slow_query_log%,该变量默认关闭。
- set global slow_query_log = 1;该命令可以打开慢查询日志，但是是临时开启。
- 设置慢查询日志所需记录的sql阈值。show variables like "slow_query_time"
- set global slow_query_time = xxx （秒）
- 永久生效需要更改my.cnf配置信息并重启
- 结合日志分析工具：mysqldumpslow

#### Explain执行计划

- 执行sql前加上explain关键字即可查看执行计划

##### 重要参数说明：

###### type: 

- system:不进行磁盘IO（几乎不可能）
- const: pk或者unique的等值查询
- eq_ref：pk或者unique的连接查询，范围查询
- ref: 非唯一索引，等值匹配，可能有多行命中。

- range：索引上的范围扫描，（如between、in、>、<）
- index：索引上的全集扫描
- all：全表扫描

###### extra:

- Using where：表示使用了where条件过滤数据。
- Using index：表示需要返回的数据都在一颗索引树上
- Using index condition：表示查询条件虽然出现在了索引列，但是有部分条件无法使用索引，会先根据能使用索引的条件搜索一遍再继续匹配无法使用索引的条件。（出现这个信息代表mysql使用了索引下推：ICP，Mysql5.6之后的特性，引擎层进行部分操作减少回表）
- Using firesort：表示得到所需结果集，需要对所有记录进行文件排序。典型的，在一个没有建立索引的列进行了order by操作，就会触发firesort。
- Using temporary：表明需要建立临时表来暂存中间结果。这类SQL性能一般较低，需要优化。典型的，同时使用了order by和group by且作用于不同字段时，就会建立临时表。

### 分库分表

#### 横向拆分（水平拆分）

- 

#### 纵向拆分



### 主从架构，集群





## MVCC

### 概念：

- 多版本并发控制（一致性非锁定读）是为了解决MySql并发环境下读操作的一致性。为了使并发环境下读操作不被锁定。
- 底层依赖于undolog实现

### 不同隔离级别下的表现

- 示例

- 准备一张user表，字段id,name,pwd 开启事务并测试

- 假定三个线程，A线程开启事务写完后提交，B线程在A线程写完后开启事务，写完后提交，C线程开启事务后一直sleep直到A、B线程执行完进行读。

  #### A线程

  ```mysql
  BEGIN;
  	UPDATE `user` 
  	SET NAME = 'tt1' 
  	WHERE
  	ID = '1';
  COMMIT;
  ```

  #### B线程

  ```mysql
  BEGIN;
  	UPDATE `user` 
  	SET NAME = 'tt' 
  	WHERE
  	ID = '1';
  COMMIT;
  ```

  #### C线程

  ```mysql
  BEGIN;
  	SELECT NAME 
  	FROM
  	USER 
  	WHERE
  	ID = '1';
  COMMIT;
  ```

- 三个版本

- 1.A线程开启事务前的快照版本。

- 2.A线程结束之后，B线程开启事务时的版本。

- 3.B线程结束提交任务之后的版本。

#### read uncommited(读未提交)

- 读未提交的情况下，B线程可以读到A线程未提交的数据，这种情况下MVCC毫无意义

#### read commited(读已提交)

- 在读已提交的隔离级别下，C线程读到的将会是第三个版本，在这一隔离级别下读到的永远都是最新的数据。
- 违反了事务的隔离性。C事务和A事务同时开启事务，而A事务结束、B事务结束、C事务在当前事务下永远能读到最新的数据。

#### repeatable  read（可重复读）

- 在可重复读的隔离级别下，C线程的事务只要未提交，永远读到的时第一个版本。即开启事务时的快照版本。
- mysql默认隔离级别为可重复读，使用next key lock解决幻读问题。

#### serial（串行化）

- 串行化情况下，所有任务都是串行执行，MVCC也无意义。





## 日志 //TODO：

### redo log

#### 概念：

- redo log 是mysql存储引擎层的实现，其目的是为了保证ACID中的持久性。

##### 为什么需要RedoLog

```tex
一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然
而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情
况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。
另一方面，事务包含 持久性 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩
溃，这个事务对数据库中所做的更改也不能丢失。
那么如何保证这个持久性呢？ 一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新
到磁盘，但是这个简单粗暴的做法有些问题
另一个解决的思路 ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系
统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内
存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统
表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表
空间的10号页面的偏移量为100处的值更新为 2 
```

![image-20221204193732267](../../../AppData/Roaming/Typora/typora-user-images/image-20221204193732267.png)



#### 刷盘时机

- InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略
- 0：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步）
- 1：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）
- 2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。

### undo log 





### bin log

### 

## 分布式事务（//TODO：）



### 2PC



### 3PC