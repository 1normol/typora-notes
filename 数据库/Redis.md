# Redis

## 持久化

- 对于内存而言，断电即失是不可避免的，Redis数据库是基于内存的数据库，因此对于数据的防护一般也会有对应的持久化策略。

### RDB（Redis DataBase）

- RDB是Redis默认的持久化方式。按照一定的时间将内存中的数据以快照的形式持久化到硬盘之中，数据文件为dump.rdb。可以通过redis.conf中的save属性来配置快照的周期。

```shell
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。

```

### AOF（Append Only File）

- Aop持久化是一种更加可靠的持久化方式，当Redis接受到数据集修改的命令时，就会把命令写入到AOF文件里。当你重启Redis时，AOF的文件将会重新执行一次以恢复数据。
- Aop持久化默认是关闭的 可以在配置文件中通过参数appendonly开启

```shell
appendonly yes
```

- 可以在配置文件中配置AOF写入策略

```shell
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

### 优缺点

#### RDB

- RDB持久化方式占用空间小，重启恢复速度快。
- RDB持久化方式在写入的时候可以选择save（主线程执行，阻塞）,bgsave（fork子线程执行，不阻塞），但是，两者都会耗费大量的cpu资源。
- RDB持久化方式可读性差，因为dump.rdb里存储的都是压缩后的二进制文件。

#### AOF

- AOF以文件形式存储命令，可读性好。
- AOF持久化的实时性更好，如果选用always几乎不会丢失资源。
- AOF占用空间大，且当Redis重启恢复资源的时候速度慢。

### 混合持久化

- 混合持久化是Redis4.0之后推出的一种持久化策略，一定程度上兼顾了RDB与AOF的优势。

- 混合持久化是为了解决当Redis实例很大，使用AOF日志文件恢复资源速度慢的问题。
- 在Redis配置文件中开启，必须先开启AOF。

```shell
# aof‐use‐rdb‐preamble yes

```

- 混合持久化将在AOF重写时，不再单纯的和aof一样，记录redis命令并写入文件，而是在重写aof命令之前的内存做rdb快照处理，并且将RDB快照和增量的AOF修改内存数据命令放在一起写入新的AOF文件，重写完成之后覆盖原有AOF文件。
- 混合持久化重启的时候先加载RDB，然后再重放增量AOF日志，因此重启的效率大大提升。
- 混合持久化的可读性也较差，该文件中既有RDB的二进制压缩快照，又有AOF记录的命令日志。

## 内存管理

- 因为内存资源是有限制的，所以需要对键进行内存管理，及时淘汰过期的键，否则将会出现OOM
- 当Redis内存满后没有清理，Redis服务只能读不能写，写时会报OOM ....的错误
- Redis对于Key，内部会维护一个过期字典，可以理解为一张hash表，字典的key存放数据的key，字典的值存放数据的过期时间，单位为long long。

#### 过期键删除策略

- 惰性删除。每次更新key的时候检查key的过期时间来淘汰缓存。
- 定期删除。一段时间抽取一部分key检查其过期时间来决定是否淘汰。

#### 内存淘汰机制

- Redis使用惰性删除+定期删除完成对过期Key的淘汰，但这种方式还是会导致大量过期key堆积问题。因此Redis提供了8种内存淘汰机制来解决因过期key导致的内存不足。

#### 从算法上区分

- LRU算法：最短最近未被使用。

- LFU算法：最不经常使用
- TTL：根据过期时间选择
- Random：随机淘汰
- LRU算法将淘汰最近一段时间最少使用的key，而LFU算法将淘汰使用次数最少的Key。总得来说，LRU算法淘汰内存的维度更关注时间，LFU算法淘汰内存的维度更加关注使用次数。

#### 从键的范围来区分

- all：所有键
- volatile：设置了过期时间的键

#### 淘汰机制：

- allkeys-lru
- volatile-lru
- allkeys-lfu
- volatile-lru
- allkeys-random
- volatile-random
- allkeys-ttl
- no-evication

## 缓存穿透、击穿、雪崩及解决方案

### 缓存穿透

#### 概念

- 缓存穿透指访问一个数据库，缓存中都不存在的key。请求直接穿过缓存打在数据库上，此时缓存就好像被穿透了一样。

#### 解决方案

- 缓存空对象，当请求的key是一个在缓存和数据库中都不存在的key时，可以在redis缓存一个空的对象返回。并在业务层进行逻辑处理。

### 缓存击穿

#### 概念

- 热点key在某个时间段过期，导致大量请求越过缓存直接打到数据库上，数据库压力倍增。

#### 解决方案

- 使用分布式锁。当多个线程访问同一个热点key时，倘若key失效，第一个拿到锁的线程执行缓存重构，其他线程阻塞等待。等到重构完成之后，其他线程直接从缓存中读取。
- 设置热点key逻辑过期。当多个线程访问同一热点key时，检查逻辑过期时间是否失效。倘若失效，使用分布式锁，拿到锁的线程异步提交缓存重构任务，返回旧的数据。

### 缓存雪崩

#### 概念

- 大面积的热点key同时失效，请求直接打到数据库，严重者可能直接导致数据库宕机。

#### 解决方案

##### 缓存不可用

- 对于热点key设置随机的TTL，避免大量热点key在同一时间失效。

##### 服务不可用

- 如果因为单机redis宕机导致缓存服务不可用，使用集群+哨兵。
- 限流策略。避免因Redis集群不可用而导致的数据库压力倍增。

## 缓存一致性

- 指数据库数据和缓存数据的一致性。

### 方案

#### 旁路缓存模式（Cache Aside Pattern）

- 该模式下，遇到写请求：先更新数据库，再删除缓存

##### 更新缓存成功，删除缓存失败

- 使用缓存更新重试机制：如果缓存更新失败，隔一段时间进行一次重试。如果多次重试还是失败，就将任务放入队列中等到缓存可用时再进行删除key。

##### 使用canal组件配合消息队列解决缓存一致性

- 通过canal订阅mysql的binlog日志，拿到具体操作的数据。再根据数据，去删除对应的缓存。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3OezNCibL5S9oyeYqJBQVZCowjAarwD2g3lIfCPsvhEHGaohPHVa47GR9d1GUgj0Eta1ketClKZjfw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

